首先，chrome的v8是最快的js引擎，所以请用chrome来运行页面

主要算法思路如下：
1、算出所有端点与终点的距离，并进行排序。
2、得到与起点相邻的无碰撞端点，并以每个无碰撞端点为起点生成到终点的路径集。
路径集生成思路是去找与终点最近的端点，判断是否有碰撞发生，如有的话就找次近一个端点，再判断，以此类推。最终会得到一个端点，然后以该端点为起点再往下找，最终会根据这些端点生成一个路径，为该路径加上起点坐标，就有了个完整路径。然后用过的路径端点不再使用，再生成下一条路径。最终端点被用光时，如果多次尝试都已无法生成路径，便不再尝试。
当然，这样的路径是有一定的误差，我们知道，比如A*算法，估值搜索范围越大，速度越慢，但精度越高。为了提高精度，以第一层端点为起点得到第二层无碰撞端点，并为每个端点生成到终点的路径集。
思路和上一步基本一样，但往下多走一级精度会提高很多，当然运算速度也下降了不少
4、将所有的路径集按距离进行排序。
5、画距离最短的路径，画之前会先判断该路径的最后端点是否为终点，并判断是否有碰撞。

两层搜索精度的运算时间大约是半分钟不到一点

由于以bus stop为起点的话用两层搜索精度还不够，所以有了V2版
V2版本在以上的基础上往下又多走了3层，精度提高，但代价是几何级数的降低了运行速度。运行时间以小时记。
如果没有耐心等待结果，目录中有个v2版本bus起点的运行结果截图fromBus_v2_Screenshot.png，可直接查看
